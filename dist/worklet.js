(function () {
    'use strict';

    // All audio processing happens within the same worklet, so this can be used to 
    // share objects between worklet processors. They should be keyed by a unique 
    // ID (e.g. generated by crypto.randomUUID() in the main thread).
    const registry = {};

    var constants = Object.freeze({
        MUTED_CLASS: "component-muted",
        BYPASSED_CLASS: "component-bypassed",
        COMPONENT_CONTAINER_CLASS: "modular-container",
        KEYBOARD_KEY_CLASS: "keyboard-key",
        KEYBOARD_KEY_PRESSED_CLASS: "keyboard-key-pressed",
        BYPASS_INDICATOR_CLASS: "bypass-indicator",
        MONITOR_VALUE_CLASS: "monitor-value",
        MONITOR_OUT_OF_BOUNDS_CLASS: "monitor-out-of-bounds",
        UNINITIALIZED_CLASS: "component-uninitialized",
        BANG_CLASS: "bang",
        BANG_PRESSED_CLASS: "bang-pressed",
        MIDI_LEARN_LISTENING_CLASS: "midi-learn-listening",
        MIDI_LEARN_ASSIGNED_CLASS: "midi-learn-assigned",
        EVENT_AUDIOPROCESS: "audioprocess",
        EVENT_MOUSEDOWN: "mousedown",
        EVENT_MOUSEUP: "mouseup",
        TRIGGER: Symbol("trigger"),
        MIN_PLAYBACK_RATE: 0.0625,
        MAX_PLAYBACK_RATE: 16.0,
        MAX_CHANNELS: 32,
        DEFAULT_NUM_CHANNELS: 2,
        MAX_ANALYZER_LENGTH: 32768,
        // Special placeholder for when an input both has no defaultValue and it has 
        // never been set.
        // TODO: need special value?
        UNSET_VALUE: undefined
    });

    var WaveType;
    (function (WaveType) {
        WaveType["SINE"] = "sine";
        WaveType["SQUARE"] = "square";
        WaveType["SAWTOOTH"] = "sawtooth";
        WaveType["TRIANGLE"] = "triangle";
        WaveType["CUSTOM"] = "custom";
        // TODO: add more
    })(WaveType || (WaveType = {}));
    var RangeType;
    (function (RangeType) {
        RangeType["SLIDER"] = "slider";
        RangeType["KNOB"] = "knob";
    })(RangeType || (RangeType = {}));
    var TimeMeasure;
    (function (TimeMeasure) {
        TimeMeasure["CYCLES"] = "cycles";
        TimeMeasure["SECONDS"] = "seconds";
        TimeMeasure["SAMPLES"] = "samples";
    })(TimeMeasure || (TimeMeasure = {}));

    (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    function range(n) {
        return Array(n).fill(0).map((v, i) => i);
    }
    function* enumerate(arr) {
        let i = 0;
        for (const x of arr) {
            yield [i++, x];
        }
    }
    function* zip(...iterables) {
        const iterators = iterables.map(iterable => iterable[Symbol.iterator]());
        let done = false;
        while (!done) {
            const current = iterators.map(iterator => iterator.next());
            done = current.some(result => result.done);
            if (!done) {
                yield current.map(result => result.value);
            }
        }
    }
    const primitiveClasses = [Number, Boolean, String, Symbol, BigInt];
    function isType(x, types) {
        types = types instanceof Array ? types : [types];
        let res = false;
        for (let type of types) {
            if (primitiveClasses.includes(type)) {
                type = type.name.toLowerCase();
            }
            if (typeof type === 'string') {
                res || (res = typeof x == type);
            }
            else {
                res || (res = x instanceof type);
            }
        }
        return res;
    }

    function toMultiChannelArray(array) {
        const proxy = new Proxy(array, {
            get(target, p, receiver) {
                if (p == "left")
                    return target[0];
                if (p == "right")
                    return target[1];
                return Reflect.get(target, p, receiver);
            }
        });
        return proxy;
    }

    const IS_WORKLET = typeof AudioWorkletProcessor != 'undefined';
    function getColumn(arr, col) {
        const result = [];
        for (let i = 0; i < arr.length; i++) {
            result.push(arr[i][col]);
        }
        return result;
    }
    function writeColumn(arr, col, values) {
        for (let i = 0; i < arr.length; i++) {
            arr[i][col] = values[i];
        }
    }
    function assertValidReturnType(result) {
        if (result === undefined) {
            throw new Error("Expected mapping function to return valid value(s), but got undefined.");
        }
    }
    function processSamples(fn, inputChunks, outputChunks, contextFactory) {
        var _a, _b;
        const numChannels = (_a = inputChunks[0]) === null || _a === void 0 ? void 0 : _a.length;
        const numSamples = (_b = inputChunks[0][0]) === null || _b === void 0 ? void 0 : _b.length;
        for (let c = 0; c < numChannels; c++) {
            for (let i = 0; i < numSamples; i++) {
                const inputs = inputChunks.map(input => input[c][i]);
                const context = contextFactory.getContext({ channelIndex: c, sampleIndex: i });
                const outputs = context.execute(fn, inputs);
                for (const [output, dest] of zip(outputs, outputChunks)) {
                    assertValidReturnType(output);
                    dest[c][i] = output;
                }
            }
        }
        // The number of output channels is the same as the input because this is not
        // determined by the user's function.
        return outputChunks.map(_ => numChannels);
    }
    function processTime(fn, inputChunks, outputChunks, contextFactory) {
        var _a;
        const numChannels = (_a = inputChunks[0]) === null || _a === void 0 ? void 0 : _a.length;
        for (let c = 0; c < numChannels; c++) {
            const inputs = inputChunks.map(input => input[c]);
            const context = contextFactory.getContext({ channelIndex: c });
            const outputs = context.execute(fn, inputs);
            for (const [output, dest] of zip(outputs, outputChunks)) {
                assertValidReturnType(output);
                dest[c].set(output);
            }
        }
        // The number of output channels is the same as the input because this is not
        // determined by the user's function.
        return outputChunks.map(_ => numChannels);
    }
    /**
     * Apply a fuction across the audio chunk (channels and time).
     *
     * @param fn
     * @param inputChunks
     * @param outputChunks
     * @returns The number of channels for each output of the function.
     */
    function processTimeAndChannels(fn, inputChunks, outputChunks, contextFactory) {
        const inputs = inputChunks.map(toMultiChannelArray);
        const context = contextFactory.getContext();
        const outputs = context.execute(fn, inputs);
        assertValidReturnType(outputs);
        for (const [output, dest] of zip(outputs, outputChunks)) {
            for (let c = 0; c < output.length; c++) {
                if (output[c] == undefined) {
                    continue; // This signifies that the channel should be empty.
                }
                dest[c].set(output[c]);
            }
        }
        return outputs.map(a => a.length);
    }
    /**
     * Apply a fuction to each sample, across channels.
     *
     * @param fn
     * @param inputChunks
     * @param outputChunks
     * @returns The number of channels for each output of the function.
     */
    function processChannels(fn, inputChunks, outputChunks, contextFactory) {
        var _a;
        const numOutputChannels = Array(outputChunks.length).fill(0);
        const numSamples = (_a = inputChunks[0][0]) === null || _a === void 0 ? void 0 : _a.length;
        for (let i = 0; i < numSamples; i++) {
            // Get the i'th sample, across all channels and inputs.
            const inputs = inputChunks.map(input => {
                const inputChannels = getColumn(input, i);
                return toMultiChannelArray(inputChannels);
            });
            const context = contextFactory.getContext({ sampleIndex: i });
            const outputChannels = context.execute(fn, inputs);
            for (const [j, [output, destChunk]] of enumerate(zip(outputChannels, outputChunks))) {
                // TODO: add NaN logic to postprocessing instead.
                writeColumn(destChunk, i, map(output, v => isFinite(v) ? v : 0));
                numOutputChannels[j] = output.length;
            }
        }
        return numOutputChannels;
    }
    function getProcessingFunction(dimension) {
        switch (dimension) {
            case "all":
                return processTimeAndChannels;
            case "channels":
                return processChannels;
            case "time":
                return processTime;
            case "none":
                return processSamples;
            default:
                throw new Error(`Invalid AudioDimension: ${dimension}. Expected one of ["all", "none", "channels", "time"]`);
        }
    }
    function mapOverChannels(dimension, data, fn) {
        switch (dimension) {
            case "all":
                return map(data, fn);
            case "channels":
                const channels = data;
                return map(channels, c => fn([c]));
            case "time":
                return fn(data);
            case "none":
                return fn([data]);
            default:
                throw new Error(`Invalid AudioDimension: ${dimension}. Expected one of ["all", "none", "channels", "time"]`);
        }
    }
    // Lightweight check that the structure is correct.
    function isCorrectOutput(dimension, output, type) {
        const typeValidation = type.__NEW__validateAny(output);
        switch (dimension) {
            case "all":
                return typeValidation && isArrayLike(output) && isArrayLike(output[0]);
            case "channels":
                // NOTE: Channels can be undefined, a special case that means empty data.
                return output == undefined || typeValidation && isArrayLike(output);
            case "time":
                return typeValidation && isArrayLike(output);
            case "none":
                return typeValidation;
            default:
                throw new Error(`Invalid AudioDimension: ${dimension}. Expected one of ["all", "none", "channels", "time"]`);
        }
    }
    function propertyIsDefined(obj, property) {
        return typeof obj === 'object'
            && obj !== null
            && property in obj
            && obj[property] != undefined;
    }
    function isArrayLike(value) {
        return isType(value, Array) || propertyIsDefined(value, 'length') && propertyIsDefined(value, 0);
    }
    /**
     * Returns a structure filled with zeroes that represents the shape of a single input or the output.
     */
    function generateZeroInput(dimension, windowSize, numChannels) {
        switch (dimension) {
            case "all":
                const frame = [];
                for (let i = 0; i < numChannels; i++) {
                    frame.push(new Float32Array(windowSize));
                }
                return toMultiChannelArray(frame);
            case "channels":
                const channels = Array(windowSize).fill(0);
                return toMultiChannelArray(channels);
            case "time":
                return new Float32Array(windowSize);
            case "none":
                return 0;
            default:
                throw new Error(`Invalid AudioDimension: ${dimension}. Expected one of ["all", "none", "channels", "time"]`);
        }
    }
    /**
     * Computes x mod y.
     */
    function mod(x, y) {
        return ((x % y) + y) % y;
    }
    function sum(iter) {
        let sm = 0;
        for (const x of iter) {
            sm += x;
        }
        return sm;
    }
    const _NO_VALUE = Symbol("_NO_VALUE");
    function allEqual(iter) {
        let lastValue = _NO_VALUE;
        for (const x of iter) {
            if (lastValue != _NO_VALUE && lastValue != x) {
                return false;
            }
            lastValue = x;
        }
        return true;
    }
    /* Safe version of TypedArray.set that doesn't throw RangeError. */
    function safeArraySet(dest, source, offset) {
        if (source.length + offset > dest.length) {
            for (let i = 0; i + offset < dest.length; i++) {
                dest[i + offset] = source[i];
            }
        }
        else {
            dest.set(source, offset);
        }
    }
    function joinTypedArrays(buffers, ArrayType = Float32Array, maxLength = Infinity) {
        const lengths = buffers.map(a => a.length);
        const outSize = Math.min(maxLength, sum(lengths));
        const result = new ArrayType(outSize);
        let currOffset = 0;
        for (let i = 0; i < buffers.length; i++) {
            if (currOffset >= outSize)
                break;
            safeArraySet(result, buffers[i], currOffset);
            currOffset += lengths[i];
        }
        return result;
    }
    function toComplexArray(real, imaginary, complexOut) {
        complexOut !== null && complexOut !== void 0 ? complexOut : (complexOut = Array(real.length * 2).fill(0));
        for (let i = 0; i < real.length; i++) {
            complexOut[i * 2] = real[i];
            imaginary && (complexOut[i * 2 + 1] = imaginary[i]);
        }
        return complexOut;
    }
    function splitComplexArray(complexArray, outReal, outImaginary) {
        const fftSize = complexArray.length / 2;
        outReal !== null && outReal !== void 0 ? outReal : (outReal = new Float32Array(fftSize));
        outImaginary !== null && outImaginary !== void 0 ? outImaginary : (outImaginary = new Float32Array(fftSize));
        for (let i = 0; i < fftSize; i++) {
            outReal[i] = complexArray[i * 2];
            outImaginary[i] = complexArray[i * 2 + 1];
        }
        return { real: outReal, imaginary: outImaginary };
    }
    function carToPol(real, imag) {
        return {
            magnitude: Math.sqrt(real * real + imag * imag),
            // Math.atan(imag / real) leads to non-invertible polar coordinates.
            phase: Math.atan2(imag, real)
        };
    }
    function carToPolArray(real, imag, magnitude, phase) {
        magnitude !== null && magnitude !== void 0 ? magnitude : (magnitude = new Float32Array(real.length));
        phase !== null && phase !== void 0 ? phase : (phase = new Float32Array(real.length));
        for (let i = 0; i < real.length; i++) {
            const polar = carToPol(real[i], imag[i]);
            magnitude[i] = polar.magnitude;
            phase[i] = polar.phase;
        }
        return { magnitude, phase };
    }
    function polToCar(magnitude, phase) {
        return {
            real: magnitude * Math.cos(phase),
            imaginary: magnitude * Math.sin(phase)
        };
    }
    function polToCarArray(magnitude, phase, real, imaginary) {
        real !== null && real !== void 0 ? real : (real = new Float32Array(magnitude.length));
        imaginary !== null && imaginary !== void 0 ? imaginary : (imaginary = new Float32Array(magnitude.length));
        for (let i = 0; i < real.length; i++) {
            const cartesian = polToCar(magnitude[i], phase[i]);
            real[i] = cartesian.real;
            imaginary[i] = cartesian.imaginary;
        }
        return { real, imaginary };
    }
    function getChannel(arr, c) {
        return arr[c % arr.length];
    }
    function map(obj, fn) {
        if (isArrayLike(obj)) {
            return Array.prototype.map.call(obj, fn);
        }
        else {
            const res = {};
            Object.entries(obj).forEach(([key, value]) => {
                const result = fn(value, key);
                result != undefined && (res[key] = result);
            });
            return res;
        }
    }
    function map2d(grid, fn) {
        return grid.map((arr, i) => arr.map((v, j) => fn(v, i, j)));
    }
    const SafeAudioWorkletProcessor = IS_WORKLET ? AudioWorkletProcessor : class AudioWorkletProcessor {
        constructor() {
            const channel = new MessageChannel();
            this.port = channel.port1;
            this.outPort = channel.port2;
        }
    };

    class BaseBufferWorkletProcessor extends SafeAudioWorkletProcessor {
        constructor({ processorOptions: { bufferId, buffer } }) {
            super();
            if (bufferId) {
                this.bufferId = bufferId;
                buffer && (this.buffer = buffer);
            }
            // Receives serialized input sent from postMessage() calls.
            // This is used to change the buffer at runtime.
            this.port.onmessage = (event) => {
                if (event.data.bufferId) {
                    // NOTE: this must be set first due to logic in the buffer getter.
                    this.bufferId = event.data.bufferId;
                }
                if (event.data.buffer) {
                    this.buffer = event.data.buffer;
                }
            };
        }
        get buffer() {
            var _a;
            if (this.bufferId == undefined) {
                return [];
            }
            return (_a = registry[this.bufferId]) !== null && _a !== void 0 ? _a : [];
        }
        set buffer(value) {
            if (this.bufferId) {
                registry[this.bufferId] = value;
            }
            else {
                throw new Error("Cannot set buffer if bufferId is not defined.");
            }
        }
        get numSamples() {
            return this.buffer.length ? this.buffer[0].length : 0;
        }
        get numChannels() {
            return this.buffer.length;
        }
        toBufferIndex(sampleIdx) {
            // Transforms the index to be within range.
            return Math.floor(mod(sampleIdx, this.numSamples));
        }
    }

    const BUFFER_WORKLET_NAME = "buffer-worklet";
    class BufferWorklet extends BaseBufferWorkletProcessor {
        process([time], [output], parameters) {
            if (!time.length) {
                return true;
            }
            for (let c = 0; c < this.numChannels; c++) {
                const bufferChannel = this.buffer[c];
                // If the buffer has more channels than the input, copy the input to 
                // fill the internal channels.
                const inChannel = time[c % time.length];
                const outChannel = output[c % output.length];
                // The input is a series of sample indices.
                for (let i = 0; i < inChannel.length; i++) {
                    const bufferIndex = this.toBufferIndex(inChannel[i]);
                    outChannel[i] = bufferChannel[bufferIndex];
                }
            }
            return true;
        }
    }

    const BUFFER_WRITER_WORKLET_NAME = "buffer-writer-worklet";
    class BufferWriterWorklet extends BaseBufferWorkletProcessor {
        constructor() {
            super(...arguments);
            this.bufferWritePeriodSec = 0.2;
            this.lastBufferWriteTime = 0;
        }
        updateMainThreadBuffer() {
            // TODO: consider using SharedArrayBuffer if available.
            // TODO: elimitate multiple copies of the same buffer when two worklet
            // processors share a buffer.
            if (this.buffer && this.buffer.length) {
                this.port.postMessage(this.buffer);
            }
        }
        process([position, value], __output, __parameters) {
            if (!position.length) {
                return true;
            }
            for (let c = 0; c < this.numChannels; c++) {
                const bufferChannel = this.buffer[c];
                // If the buffer has more channels than the input, copy the input to 
                // fill the internal channels.
                const posChannel = position[c % position.length];
                const valChannel = value[c % value.length];
                // The input is a series of sample indices and values.
                for (let i = 0; i < posChannel.length; i++) {
                    const bufferIndex = this.toBufferIndex(posChannel[i]);
                    bufferChannel[bufferIndex] = valChannel[i];
                }
            }
            if (currentTime - this.lastBufferWriteTime > this.bufferWritePeriodSec) {
                this.updateMainThreadBuffer();
                this.lastBufferWriteTime = currentTime;
            }
            return true;
        }
    }

    var queue = {};

    /**
     * @license MIT
     * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
     *
     * @class
     */

    let Queue$1 = class Queue {
      /**
       * Creates a queue.
       * @param {array} [elements]
       */
      constructor(elements) {
        this._elements = Array.isArray(elements) ? elements : [];
        this._offset = 0;
      }

      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      enqueue(element) {
        this._elements.push(element);
        return this;
      }

      /**
       * Adds an element to the back of the queue.
       * @public
       * @param {number|string|object} element
       */
      push(element) {
        return this.enqueue(element);
      }

      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      dequeue() {
        if (this.size() === 0) return null;

        const first = this.front();
        this._offset += 1;

        if (this._offset * 2 < this._elements.length) return first;

        // only remove dequeued elements when reaching half size
        // to decrease latency of shifting elements.
        this._elements = this._elements.slice(this._offset);
        this._offset = 0;
        return first;
      }

      /**
       * Dequeues the front element in the queue.
       * @public
       * @returns {number|string|object}
       */
      pop() {
        return this.dequeue();
      }

      /**
       * Returns the front element of the queue.
       * @public
       * @returns {number|string|object}
       */
      front() {
        return this.size() > 0 ? this._elements[this._offset] : null;
      }

      /**
       * Returns the back element of the queue.
       * @public
       * @returns {number|string|object}
       */
      back() {
        return this.size() > 0 ? this._elements[this._elements.length - 1] : null;
      }

      /**
       * Returns the number of elements in the queue.
       * @public
       * @returns {number}
       */
      size() {
        return this._elements.length - this._offset;
      }

      /**
       * Checks if the queue is empty.
       * @public
       * @returns {boolean}
       */
      isEmpty() {
        return this.size() === 0;
      }

      /**
       * Returns the remaining elements in the queue as an array.
       * @public
       * @returns {array}
       */
      toArray() {
        return this._elements.slice(this._offset);
      }

      /**
       * Clears the queue.
       * @public
       */
      clear() {
        this._elements = [];
        this._offset = 0;
      }

      /**
       * Creates a shallow copy of the queue.
       * @public
       * @return {Queue}
       */
      clone() {
        return new Queue(this._elements.slice(this._offset));
      }

      /**
       * Creates a queue from an existing array.
       * @public
       * @static
       * @param {array} elements
       * @return {Queue}
       */
      static fromArray(elements) {
        return new Queue(elements);
      }
    };

    queue.Queue = Queue$1;

    const { Queue } = queue;

    var Queue_1 = Queue;

    function checkRange(i, min, max) {
        if (i >= max || i < min) {
            throw new RangeError(`Index '${i}' is not in range of the view.`);
        }
        return true;
    }
    function isIndexInRange(v, length) {
        const isNumber = typeof v != 'symbol' && Number.isInteger(+v);
        return isNumber && checkRange(+v, 0, length);
    }
    class ArrayView {
        get proxy() {
            var _a;
            const length = this.length;
            return (_a = this._proxy) !== null && _a !== void 0 ? _a : (this._proxy = new Proxy(this, {
                get(target, p, receiver) {
                    if (isIndexInRange(p, length)) {
                        return target.get(+p);
                    }
                    else {
                        return Reflect.get(target, p, receiver);
                    }
                },
                set(target, p, newValue, receiver) {
                    if (isIndexInRange(p, length)) {
                        target.set(+p, newValue);
                        return true;
                    }
                    else {
                        return Reflect.set(target, p, newValue, receiver);
                    }
                }
            }));
        }
        constructor(privateConstructor, get, set, length) {
            this.get = get;
            this.set = set;
            this.length = length;
            if (privateConstructor != ArrayView.PRIVATE_CONSTRUCTOR) {
                throw new Error("Instances must be constructed using one of the ArrayView.create*() methods.");
            }
        }
        findLast(predicate, thisArg) {
            return Array.prototype.findLast.call(this.proxy, predicate, thisArg);
        }
        findLastIndex(predicate, thisArg) {
            return Array.prototype.findLastIndex.call(this.proxy, predicate, thisArg);
        }
        toReversed() {
            return ArrayView.createReversedView(this);
        }
        toSorted(compareFn) {
            return Array.prototype.toSorted.call(this.proxy, compareFn);
        }
        toSpliced(...args) {
            // @ts-ignore 
            return Array.prototype.toSpliced.call(this.proxy, ...args);
        }
        with(index, value) {
            return Array.prototype.with.call(this.proxy, index, value);
        }
        at(index) {
            return this.get(index);
        }
        flatMap(callback, thisArg) {
            return Array.prototype.flatMap.call(this.proxy, callback, thisArg);
        }
        flat(depth) {
            return Array.prototype.flat.call(this.proxy, depth);
        }
        toLocaleString(locales, options) {
            throw new Error("Method not implemented.");
        }
        pop() {
            if (this.length) {
                const v = this.get(this.length - 1);
                this.length -= 1;
                return v;
            }
        }
        push(...items) {
            throw new Error("Method not implemented.");
        }
        concat(...items) {
            return Array.prototype.concat.call(this.proxy, ...items);
        }
        join(separator) {
            return Array.prototype.join.call(this.proxy, separator);
        }
        reverse() {
            return ArrayView.createReversedView(this.proxy);
        }
        shift() {
            throw new Error("Method not implemented.");
        }
        slice(start, end) {
            return ArrayView.createSliceView(this.proxy, start, end);
        }
        sort(compareFn) {
            return Array.prototype.sort.call(this.proxy, compareFn);
        }
        splice(start, deleteCount, ...rest) {
            throw new Error("Method not implemented.");
        }
        unshift(...items) {
            throw new Error("Method not implemented.");
        }
        indexOf(searchElement, fromIndex) {
            return Array.prototype.indexOf.call(this.proxy, searchElement, fromIndex);
        }
        lastIndexOf(searchElement, fromIndex) {
            return Array.prototype.lastIndexOf.call(this.proxy, searchElement, fromIndex);
        }
        every(predicate, thisArg) {
            return Array.prototype.every.call(this.proxy, predicate, thisArg);
        }
        some(predicate, thisArg) {
            return Array.prototype.some.call(this.proxy, predicate, thisArg);
        }
        forEach(callbackfn, thisArg) {
            return Array.prototype.forEach.call(this.proxy, callbackfn, thisArg);
        }
        map(callbackfn, thisArg) {
            return Array.prototype.map.call(this.proxy, callbackfn, thisArg);
        }
        filter(predicate, thisArg) {
            return Array.prototype.filter.call(this.proxy, predicate, thisArg);
        }
        reduce(callbackfn, initialValue) {
            return Array.prototype.reduce.call(this.proxy, callbackfn, initialValue);
        }
        reduceRight(callbackfn, initialValue) {
            return Array.prototype.reduceRight.call(this.proxy, callbackfn, initialValue);
        }
        find(predicate, thisArg) {
            return Array.prototype.find.call(this.proxy, predicate, thisArg);
        }
        findIndex(predicate, thisArg) {
            return Array.prototype.findIndex.call(this.proxy, predicate, thisArg);
        }
        fill(value, start, end) {
            return Array.prototype.fill.call(this.proxy, value, start, end);
        }
        copyWithin(target, start, end) {
            return Array.prototype.copyWithin.call(this.proxy, target, start, end);
        }
        entries() {
            return Array.prototype.entries.call(this.proxy);
        }
        keys() {
            return Array.prototype.keys.call(this.proxy);
        }
        values() {
            return Array.prototype.values.call(this.proxy);
        }
        includes(searchElement, fromIndex) {
            return Array.prototype.includes.call(this.proxy, searchElement, fromIndex);
        }
        [Symbol.iterator]() {
            return Array.prototype[Symbol.iterator].call(this.proxy);
        }
        toString() {
            return `ArrayView (${this.length})`;
        }
        toArray() {
            return [...this];
        }
        static create(get, set, length) {
            const view = new ArrayView(ArrayView.PRIVATE_CONSTRUCTOR, get, set, length);
            return view.proxy;
        }
        static createFromDataLocationFn(getDataLocation, length) {
            return this.create(function get(i) {
                const data = getDataLocation(i);
                return data.array[data.index];
            }, function set(i, v) {
                const data = getDataLocation(i);
                data.array[data.index] = v;
            }, length);
        }
        static createConcatView(...arrays) {
            const lengths = arrays.map(a => a.length);
            const lengthSum = lengths.reduce((sum, c) => sum + c, 0);
            function getDataLocation(i) {
                for (let arrayIndex = 0; arrayIndex < arrays.length; arrayIndex++) {
                    if (i < lengths[arrayIndex]) {
                        return {
                            array: arrays[arrayIndex],
                            index: i
                        };
                    }
                    else {
                        i -= lengths[arrayIndex];
                    }
                }
                throw new RangeError(`Index '${i}' is not in range of the view.`);
            }
            return this.createFromDataLocationFn(getDataLocation, lengthSum);
        }
        static createSliceView(array, startIndex, endIndex) {
            // TODO: validate these numbers.
            startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0);
            endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = array.length);
            function getDataLocation(i) {
                const index = i + startIndex;
                return { array, index };
            }
            return this.createFromDataLocationFn(getDataLocation, endIndex - startIndex);
        }
        static createReindexedView(array, indices) {
            function getDataLocation(i) {
                return { array, index: indices[i] };
            }
            return this.createFromDataLocationFn(getDataLocation, indices.length);
        }
        static createInterleavedView(...arrays) {
            let singleArrLength = undefined;
            const numArrs = arrays.length;
            for (const arr of arrays) {
                singleArrLength !== null && singleArrLength !== void 0 ? singleArrLength : (singleArrLength = arr.length);
                if (arr.length != singleArrLength) {
                    throw new Error(`Each array to interleave must be the same length. Expected ${singleArrLength}, got ${arr.length}`);
                }
            }
            function getDataLocation(i) {
                const index = Math.floor(i / numArrs);
                const arrIndex = i % numArrs;
                return { array: arrays[arrIndex], index };
            }
            return this.createFromDataLocationFn(getDataLocation, singleArrLength * numArrs);
        }
        static createDeinterleavedViews(array, numViews) {
            let length = array.length / numViews;
            if (!Number.isInteger(length)) {
                throw new Error(`The length of the array must be exactly divisible by numViews. Given numViews=${numViews}, array.length=${array.length}`);
            }
            const views = [];
            for (let viewIndex = 0; viewIndex < numViews; viewIndex++) {
                function getDataLocation(i) {
                    return { array, index: i * numViews + viewIndex };
                }
                const view = this.createFromDataLocationFn(getDataLocation, length);
                views.push(view);
            }
            return views;
        }
        static createReversedView(array) {
            function getDataLocation(i) {
                return { array, index: array.length - (i + 1) };
            }
            return this.createFromDataLocationFn(getDataLocation, array.length);
        }
    }
    ArrayView.PRIVATE_CONSTRUCTOR = Symbol('PRIVATE_CONSTRUCTOR');

    /**
     * A Queue that allows adding and popping many elements at a time, without copying the underlying data.
     */
    class ChunkedQueue {
        constructor() {
            this.queue = new Queue_1();
            /**
             * Records how far into this.queue.front() we've already read.
             */
            this.numElementsAlreadyRead = 0;
            this.length = 0;
        }
        getChunk(numElements, defaultValue, removeItems) {
            let numPoppedElements = 0;
            let lengthAfterPop = this.length;
            let numElementsRead = this.numElementsAlreadyRead;
            const queue = removeItems ? this.queue : this.queue.clone();
            const arrsToConcat = [];
            while (numPoppedElements < numElements) {
                let arr = queue.front();
                if (arr == undefined) {
                    // Fill rest with default value.
                    arrsToConcat.push(Array(numElements - numPoppedElements).fill(defaultValue));
                    break;
                }
                if (numElementsRead) {
                    // Only look after the ones that have been read.
                    arr = ArrayView.createSliceView(arr, numElementsRead);
                }
                numPoppedElements += arr.length;
                if (numPoppedElements <= numElements) {
                    // Safe to remove, as we used up all the elements in the array.
                    queue.pop();
                    numElementsRead = 0;
                }
                else {
                    // We don't need to use the whole array. Only look at first (oldest) 
                    // values and keep the array around.
                    const numUnused = numPoppedElements - numElements;
                    numElementsRead += (arr.length - numUnused);
                    arr = ArrayView.createSliceView(arr, 0, arr.length - numUnused);
                }
                arrsToConcat.push(arr);
                lengthAfterPop -= arr.length;
            }
            if (removeItems) {
                this.numElementsAlreadyRead = numElementsRead;
                this.length = lengthAfterPop;
            }
            return ArrayView.createConcatView(...arrsToConcat);
        }
        popChunk(numElements, defaultValue) {
            return this.getChunk(numElements, defaultValue, true);
        }
        peekChunk(numElements, defaultValue) {
            return this.getChunk(numElements, defaultValue, false);
        }
        addChunk(arr) {
            this.queue.push(arr);
            this.length += arr.length;
        }
    }
    /**
     * A class that abstracts out the size of actual window received, ensuring all windows have a specific size.
     */
    class AudioStreamScheduler {
        // TODO: consider allocating inputQueues and outputQueues beforehand and 
        // relying on the numChannelsPerOutput property.
        constructor(windowSize, numInputs, numOutputs, processWindow, getChunkStartIndex = () => 0) {
            this.windowSize = windowSize;
            this.numInputs = numInputs;
            this.numOutputs = numOutputs;
            this.processWindow = processWindow;
            this.getChunkStartIndex = getChunkStartIndex;
        }
        get inputQueueSize() {
            return this.inputQueues[0][0].length;
        }
        popInputChunk(size) {
            return map2d(this.inputQueues, queue => queue.popChunk(size, 0));
        }
        peekInputChunk(size) {
            return map2d(this.inputQueues, queue => queue.peekChunk(size, 0));
        }
        popOutputChunk(size) {
            return map2d(this.outputQueues, queue => queue.popChunk(size, 0));
        }
        addToOutputQueue(outputs) {
            map2d(this.outputQueues, (queue, i, c) => queue.addChunk(outputs[i][c]));
        }
        addToInputQueue(inputs) {
            map2d(this.inputQueues, (queue, i, c) => queue.addChunk(inputs[i][c]));
        }
        *getScheduledInputBatches() {
            // Process all the data we can.
            while (this.inputQueueSize >= this.windowSize) {
                const inputChunk = this.peekInputChunk(this.windowSize);
                const startIndex = this.getChunkStartIndex(inputChunk);
                if (startIndex) {
                    // Pop all elements before it. The next loop will start there.
                    this.popInputChunk(startIndex);
                }
                else if (startIndex == -1) {
                    this.popInputChunk(this.windowSize);
                }
                else {
                    yield this.popInputChunk(this.windowSize);
                }
            }
        }
        processScheduledBatches() {
            let keepAlive;
            for (const inputBatch of this.getScheduledInputBatches()) {
                const numChannels = inputBatch[0].length;
                // Each input batch is of length this.windowSize
                const outputs = [];
                for (let i = 0; i < this.numOutputs; i++) {
                    const output = [];
                    for (let c = 0; c < numChannels; c++) {
                        output.push(new Float32Array(inputBatch[0][0].length));
                    }
                    outputs.push(output);
                }
                // If any want to keep-alive, keep alive.
                keepAlive !== null && keepAlive !== void 0 ? keepAlive : (keepAlive = false);
                const res = this.processWindow(map2d(inputBatch, v => v.toArray()), outputs);
                keepAlive || (keepAlive = res);
                this.addToOutputQueue(outputs);
            }
            // If no batches were yet scheduled (keepAlive==undefined), keep alive.
            return keepAlive !== null && keepAlive !== void 0 ? keepAlive : true;
        }
        copyToOutputs(queuedOutputs, outputs) {
            for (let i = 0; i < outputs.length; i++) {
                for (let c = 0; c < outputs[i].length; c++) {
                    outputs[i][c].set(queuedOutputs[i][c]);
                }
            }
        }
        process(inputs, outputs) {
            var _a, _b;
            // TODO: fill in dummy values if given input = []
            if (!(inputs.length && inputs.every(i => i.length) && outputs.length && outputs.every(i => i.length))) {
                // TODO: how do we handle "input-based" scheduling if there are zero 
                // inputs?
                console.error("0-input and 0-channel functions are not supported yet. This frame will be ignored.");
                return true;
            }
            //if (inputs.length == 3) console.log(["inputs", ...inputs[0][0]])
            // If arrays are overwritten by WebAudio API, we need to copy. 
            // TODO: maybe remove.
            // Initalize queues (only happens once).
            (_a = this.inputQueues) !== null && _a !== void 0 ? _a : (this.inputQueues = map2d(inputs, _ => new ChunkedQueue()));
            (_b = this.outputQueues) !== null && _b !== void 0 ? _b : (this.outputQueues = map2d(outputs, _ => new ChunkedQueue()));
            // Add input to input queue.
            this.addToInputQueue(inputs);
            // Process output if needed and add the result to the output queue.
            this.processScheduledBatches();
            // Pop output from output queue.
            const queuedOutputs = this.popOutputChunk(inputs[0][0].length);
            //console.log(queuedOutputs[0][0][0])
            /* if (queuedOutputs[0][0][0] == 768) {
              throw new Error("" + queuedOutputs[0][0][0])
            } */
            // Write to current outputs.
            this.copyToOutputs(queuedOutputs, outputs);
            //if (outputs.length == 3) console.log(["outputs", ...outputs[0][0]])
            //
            //console.log(["inputs", inputs[0][0]])
            return true;
        }
    }
    /**
     * Uses input / output queuing to abstract sequence length away from the size of arrays passed to process().
     */
    class BaseWorkletProcessor extends SafeAudioWorkletProcessor {
        constructor(windowSize, numInputs, numOutputs) {
            super();
            this.windowSize = windowSize;
            this.numInputs = numInputs;
            this.numOutputs = numOutputs;
            if (this.numInputs == 0) {
                throw new RangeError("0-input worklets are not supported yet.");
            }
            if (this.constructor.prototype.process != BaseWorkletProcessor.prototype.process) {
                throw new Error("The process() method must not be overridden. Overwrite processWindow() instead.");
            }
            this.scheduler = new AudioStreamScheduler(windowSize, numInputs, numOutputs, this.processWindow.bind(this), this.getInputChunkStartIndex.bind(this));
        }
        /**
         * Abstract method that receives chunks of size this.windowSize.
         */
        processWindow(inputs, outputs) {
            throw new Error("Not implemented.");
        }
        /**
         * This determines the index in the chunk at which to start the batch, and should be overridden by the subclass.
         *
         * This is mainly useful in situations where a specific chunk of data is required for the operation, such as magnitude values from 0 to 1023 in an FFT with a window size of 1024. If this method did not exist, an FFT frame could contain values like `[896 through 1023, 0 through 895]`, which should actually be processed as two separate frames--e.g. it should be delayed by 128 samples to process the frame starting from 0.
         *
         * Elements before this index will be discarded, and the batch will not be popped until it is full size. A return value of -1 indicates that the entire chunk should be discarded.
         */
        getInputChunkStartIndex(chunk) {
            return 0;
        }
        process(inputs, outputs, parameters // TODO: handle parameters?
        ) {
            /* const numChannels = Math.max(
              ...inputs.map(v => v.length),
              ...outputs.map(v => v.length)
            ) */
            try {
                const numChannels = Math.max(...inputs.map(input => input.length));
                const numSamples = Math.max(...inputs.map(input => { var _a; return (_a = input[0]) === null || _a === void 0 ? void 0 : _a.length; }));
                // Fill in empty ("disconnected" inputs).
                inputs = inputs.map((input, i) => {
                    if (input.length) {
                        // Make a *copy*. This is necessary because the Web Audio API reuses
                        // input buffers between process() calls so otherwise the data will be
                        // overwritten.
                        return input.map(c => new Float32Array(c));
                    }
                    const emptyChannels = Array(numChannels).fill([]);
                    return emptyChannels.map(_ => new Float32Array(numSamples));
                });
                return this.scheduler.process(inputs, outputs);
            }
            catch (e) {
                console.error(`Encountered worklet error while processing the following input frame:`);
                console.error(inputs);
                throw e;
            }
        }
    }
    /*
    const scheduler = new AudioStreamScheduler(1024, 1, 3, (inputs, outputs) => {
      map2d(outputs, arr => arr.map((v, k) => arr[k] = inputs[0][0][k]))
      console.log(["true!", outputs])
    })

    const inputs = [[new Float32Array(128)]]
    for (let i = 0; i < 128; i++) {
      map2d(inputs, arr => arr.map((_, i) => arr[i] = Math.random()))
      const outputs = [[new Float32Array(128)], [new Float32Array(128)], [new Float32Array(128)]]
      scheduler.process(inputs, outputs)
      console.log(outputs)
    }

    scheduler.process([[new Float32Array([10, 11, 12, 13])]], [[new Float32Array(4)]])
    scheduler.process([[new Float32Array([14])]], [[new Float32Array(1)]])
    scheduler.process([[new Float32Array([15])]], [[new Float32Array(1)]])
    scheduler.process([[new Float32Array([16, 17])]], [[new Float32Array(2)]])
    scheduler.process([[]], [[new Float32Array([18, 19, 20, 21, 22])]]) */

    // fft.js from https://github.com/indutny/fft.js/tree/master
    // @ts-ignore
    var FFTJS = function (t) { function r(e) { if (i[e])
        return i[e].exports; var o = i[e] = { i: e, l: !1, exports: {} }; return t[e].call(o.exports, o, o.exports, r), o.l = !0, o.exports; } var i = {}; return r.m = t, r.c = i, r.i = function (t) { return t; }, r.d = function (t, i, e) { r.o(t, i) || Object.defineProperty(t, i, { configurable: !1, enumerable: !0, get: e }); }, r.n = function (t) { var i = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return r.d(i, "a", i), i; }, r.o = function (t, r) { return Object.prototype.hasOwnProperty.call(t, r); }, r.p = "", r(r.s = 0); }([function (t, r, i) {
            function e(t) { if (this.size = 0 | t, this.size <= 1 || 0 != (this.size & this.size - 1))
                throw new Error("FFT size must be a power of two and bigger than 1"); this._csize = t << 1; for (var r = new Array(2 * this.size), i = 0; i < r.length; i += 2) {
                var e = Math.PI * i / this.size;
                r[i] = Math.cos(e), r[i + 1] = -Math.sin(e);
            } this.table = r; for (var o = 0, n = 1; this.size > n; n <<= 1)
                o++; this._width = o % 2 == 0 ? o - 1 : o, this._bitrev = new Array(1 << this._width); for (var s = 0; s < this._bitrev.length; s++) {
                this._bitrev[s] = 0;
                for (var a = 0; a < this._width; a += 2) {
                    var h = this._width - a - 2;
                    this._bitrev[s] |= (s >>> a & 3) << h;
                }
            } this._out = null, this._data = null, this._inv = 0; }
            t.exports = e, e.prototype.fromComplexArray = function (t, r) { for (var i = r || new Array(t.length >>> 1), e = 0; e < t.length; e += 2)
                i[e >>> 1] = t[e]; return i; }, e.prototype.createComplexArray = function () { for (var t = new Array(this._csize), r = 0; r < t.length; r++)
                t[r] = 0; return t; }, e.prototype.toComplexArray = function (t, r) { for (var i = r || this.createComplexArray(), e = 0; e < i.length; e += 2)
                i[e] = t[e >>> 1], i[e + 1] = 0; return i; }, e.prototype.completeSpectrum = function (t) { for (var r = this._csize, i = r >>> 1, e = 2; e < i; e += 2)
                t[r - e] = t[e], t[r - e + 1] = -t[e + 1]; }, e.prototype.transform = function (t, r) { if (t === r)
                throw new Error("Input and output buffers must be different"); this._out = t, this._data = r, this._inv = 0, this._transform4(), this._out = null, this._data = null; }, e.prototype.realTransform = function (t, r) { if (t === r)
                throw new Error("Input and output buffers must be different"); this._out = t, this._data = r, this._inv = 0, this._realTransform4(), this._out = null, this._data = null; }, e.prototype.inverseTransform = function (t, r) { if (t === r)
                throw new Error("Input and output buffers must be different"); this._out = t, this._data = r, this._inv = 1, this._transform4(); for (var i = 0; i < t.length; i++)
                t[i] /= this.size; this._out = null, this._data = null; }, e.prototype._transform4 = function () { var t, r, i = this._out, e = this._csize, o = this._width, n = 1 << o, s = e / n << 1, a = this._bitrev; if (4 === s)
                for (t = 0, r = 0; t < e; t += s, r++) {
                    var h = a[r];
                    this._singleTransform2(t, h, n);
                }
            else
                for (t = 0, r = 0; t < e; t += s, r++) {
                    var f = a[r];
                    this._singleTransform4(t, f, n);
                } var u = this._inv ? -1 : 1, _ = this.table; for (n >>= 2; n >= 2; n >>= 2) {
                s = e / n << 1;
                var l = s >>> 2;
                for (t = 0; t < e; t += s)
                    for (var p = t + l, v = t, c = 0; v < p; v += 2, c += n) {
                        var d = v, m = d + l, y = m + l, b = y + l, w = i[d], g = i[d + 1], z = i[m], T = i[m + 1], x = i[y], A = i[y + 1], C = i[b], E = i[b + 1], F = w, I = g, M = _[c], R = u * _[c + 1], O = z * M - T * R, P = z * R + T * M, j = _[2 * c], S = u * _[2 * c + 1], J = x * j - A * S, k = x * S + A * j, q = _[3 * c], B = u * _[3 * c + 1], D = C * q - E * B, G = C * B + E * q, H = F + J, K = I + k, L = F - J, N = I - k, Q = O + D, U = P + G, V = u * (O - D), W = u * (P - G), X = H + Q, Y = K + U, Z = H - Q, $ = K - U, tt = L + W, rt = N - V, it = L - W, et = N + V;
                        i[d] = X, i[d + 1] = Y, i[m] = tt, i[m + 1] = rt, i[y] = Z, i[y + 1] = $, i[b] = it, i[b + 1] = et;
                    }
            } }, e.prototype._singleTransform2 = function (t, r, i) { var e = this._out, o = this._data, n = o[r], s = o[r + 1], a = o[r + i], h = o[r + i + 1], f = n + a, u = s + h, _ = n - a, l = s - h; e[t] = f, e[t + 1] = u, e[t + 2] = _, e[t + 3] = l; }, e.prototype._singleTransform4 = function (t, r, i) { var e = this._out, o = this._data, n = this._inv ? -1 : 1, s = 2 * i, a = 3 * i, h = o[r], f = o[r + 1], u = o[r + i], _ = o[r + i + 1], l = o[r + s], p = o[r + s + 1], v = o[r + a], c = o[r + a + 1], d = h + l, m = f + p, y = h - l, b = f - p, w = u + v, g = _ + c, z = n * (u - v), T = n * (_ - c), x = d + w, A = m + g, C = y + T, E = b - z, F = d - w, I = m - g, M = y - T, R = b + z; e[t] = x, e[t + 1] = A, e[t + 2] = C, e[t + 3] = E, e[t + 4] = F, e[t + 5] = I, e[t + 6] = M, e[t + 7] = R; }, e.prototype._realTransform4 = function () { var t, r, i = this._out, e = this._csize, o = this._width, n = 1 << o, s = e / n << 1, a = this._bitrev; if (4 === s)
                for (t = 0, r = 0; t < e; t += s, r++) {
                    var h = a[r];
                    this._singleRealTransform2(t, h >>> 1, n >>> 1);
                }
            else
                for (t = 0, r = 0; t < e; t += s, r++) {
                    var f = a[r];
                    this._singleRealTransform4(t, f >>> 1, n >>> 1);
                } var u = this._inv ? -1 : 1, _ = this.table; for (n >>= 2; n >= 2; n >>= 2) {
                s = e / n << 1;
                var l = s >>> 1, p = l >>> 1, v = p >>> 1;
                for (t = 0; t < e; t += s)
                    for (var c = 0, d = 0; c <= v; c += 2, d += n) {
                        var m = t + c, y = m + p, b = y + p, w = b + p, g = i[m], z = i[m + 1], T = i[y], x = i[y + 1], A = i[b], C = i[b + 1], E = i[w], F = i[w + 1], I = g, M = z, R = _[d], O = u * _[d + 1], P = T * R - x * O, j = T * O + x * R, S = _[2 * d], J = u * _[2 * d + 1], k = A * S - C * J, q = A * J + C * S, B = _[3 * d], D = u * _[3 * d + 1], G = E * B - F * D, H = E * D + F * B, K = I + k, L = M + q, N = I - k, Q = M - q, U = P + G, V = j + H, W = u * (P - G), X = u * (j - H), Y = K + U, Z = L + V, $ = N + X, tt = Q - W;
                        if (i[m] = Y, i[m + 1] = Z, i[y] = $, i[y + 1] = tt, 0 !== c) {
                            if (c !== v) {
                                var rt = N, it = -Q, et = K, ot = -L, nt = -u * X, st = -u * W, at = -u * V, ht = -u * U, ft = rt + nt, ut = it + st, _t = et + ht, lt = ot - at, pt = t + p - c, vt = t + l - c;
                                i[pt] = ft, i[pt + 1] = ut, i[vt] = _t, i[vt + 1] = lt;
                            }
                        }
                        else {
                            var ct = K - U, dt = L - V;
                            i[b] = ct, i[b + 1] = dt;
                        }
                    }
            } }, e.prototype._singleRealTransform2 = function (t, r, i) { var e = this._out, o = this._data, n = o[r], s = o[r + i], a = n + s, h = n - s; e[t] = a, e[t + 1] = 0, e[t + 2] = h, e[t + 3] = 0; }, e.prototype._singleRealTransform4 = function (t, r, i) { var e = this._out, o = this._data, n = this._inv ? -1 : 1, s = 2 * i, a = 3 * i, h = o[r], f = o[r + i], u = o[r + s], _ = o[r + a], l = h + u, p = h - u, v = f + _, c = n * (f - _), d = l + v, m = p, y = -c, b = l - v, w = p, g = c; e[t] = d, e[t + 1] = 0, e[t + 2] = m, e[t + 3] = y, e[t + 4] = b, e[t + 5] = 0, e[t + 6] = w, e[t + 7] = g; };
        }]);

    const FFT_WORKLET_NAME = "fft-worklet";
    const IFFT_WORKLET_NAME = "ifft-worklet";
    class BaseFFTWorkletProcessor extends BaseWorkletProcessor {
        constructor({ numberOfInputs, numberOfOutputs, processorOptions: { useComplexValuedFft = false, fftSize = 128 } }) {
            super(fftSize, numberOfInputs, numberOfOutputs);
            this.fftSize = fftSize;
            this.fft = new FFTJS(this.fftSize);
            this.useComplexValuedFft = useComplexValuedFft;
        }
    }
    class FFTWorklet extends BaseFFTWorkletProcessor {
        processChannel([realIn, imagIn], [sync, output1, output2]) {
            const complexInput = toComplexArray(realIn, imagIn);
            const complexOutput = this.fft.createComplexArray();
            this.fft.transform(complexOutput, complexInput);
            // TODO: does this need normalization?
            if (this.useComplexValuedFft) { // Outputs are [real, imaginary].
                // The output arrays are mutated.
                splitComplexArray(complexOutput, 
                /*real=*/ output1, 
                /*imaginary=*/ output2);
            }
            else { // Outputs are [magnitude, phase].
                const [real, imaginary] = ArrayView.createDeinterleavedViews(complexOutput, 2);
                // The magnitude and phase arrays will be mutated.
                carToPolArray(real, imaginary, 
                /*magnitude=*/ output1, 
                /*phase=*/ output2);
                // Normalize magnitudes.
                Array.prototype.forEach.call(output1, (v, i) => output1[i] = v / output1.length);
            }
            // Sync runs from 0 to fftSize-1 and ensures outputs are kept in sync 
            // with the processing frame.
            Array.prototype.forEach.call(output1, (_, i) => sync[i] = i);
        }
        processWindow([realSignal, imaginarySignal], [sync, output1, output2]) {
            const numChannels = Math.max(realSignal.length, imaginarySignal.length);
            for (let c = 0; c < numChannels; c++) {
                this.processChannel([getChannel(realSignal, c), getChannel(imaginarySignal, c)], [getChannel(sync, c), getChannel(output1, c), getChannel(output2, c)]);
            }
            return true;
        }
    }
    class IFFTWorklet extends BaseFFTWorkletProcessor {
        resync(arr, sync) {
            const result = new Float32Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
                result[sync[i]] = arr[i];
            }
            return result;
        }
        getInputChunkStartIndex(chunk) {
            // The sync signal goes from 0 to this.fftSize-1. We want the first index
            // such that it is the beginning of this ramp, e.g. a zero followed by a 
            // 1.
            const sync = chunk[0][0];
            return sync.findIndex((v, i, a) => i + 1 < sync.length && v == 0 && a[i + 1] == 1);
        }
        processChannel([__sync, input1, input2], [realSignal, imaginarySignal]) {
            // Note that the input chunk will be synced to the FFT frame, thanks to 
            // the logic in getInputChunkStartIndex. So we don't need __sync in this
            // method even though it is critical for FFT frame alignment.
            let real;
            let imaginary;
            if (this.useComplexValuedFft) { // Inputs are [real, imaginary].
                real = input1;
                imaginary = input2;
            }
            else { // Inputs are [magnitude, phase].
                // De-normalize magnitudes.
                map(input1, (v, i) => input1[i] = v * input1.length);
                const complex = polToCarArray(
                /*magnitude=*/ input1, 
                /*phase=*/ input2);
                real = complex.real;
                imaginary = complex.imaginary;
            }
            const complexInput = ArrayView.createInterleavedView(real, imaginary);
            const complexOutput = this.fft.createComplexArray();
            this.fft.inverseTransform(complexOutput, complexInput);
            // The real and imaginary arrays will be mutated.
            splitComplexArray(complexOutput, realSignal, imaginarySignal);
        }
        processWindow([sync, input1, input2], [realSignal, imaginarySignal]) {
            // Empty input
            if (sync.length == 0)
                return true;
            const numChannels = Math.max(input1.length, input2.length, realSignal.length, imaginarySignal.length);
            for (let c = 0; c < numChannels; c++) {
                this.processChannel([getChannel(sync, c), getChannel(input1, c), getChannel(input2, c)], [getChannel(realSignal, c), getChannel(imaginarySignal, c)]);
            }
            return true;
        }
    }

    // NOTE: IODatatypes always process one channel at a time.
    class IODatatype {
        constructor() {
            this.name = this.constructor.name;
        }
        toString() {
            return `${this.name} (${this.dataspecString})`;
        }
        static create(dtype, name) {
            switch (dtype.toLowerCase()) {
                case "fft":
                case "stft":
                    return new stft();
                case "audio":
                    return new audio();
                case "control":
                    return new control(name);
                default:
                    throw new Error(`Unrecognized dtype ${dtype}. Supported datatypes: ['stft', 'audio', 'control']`);
            }
        }
    }
    class stft extends IODatatype {
        constructor(windowSize) {
            super();
            this.windowSize = windowSize;
            this.dataspecString = '{ magnitude: ArrayLike<number>, phase: ArrayLike<number> }';
            this.numAudioStreams = 3;
        }
        channelFromAudioData(frame) {
            if (!isType(frame.audioStreams[0], Array)) {
                throw new Error("STFT data must be arrays.");
            }
            // NOTE: Ignore the first audio stream (sync).
            return {
                magnitude: frame.audioStreams[1],
                phase: frame.audioStreams[2]
                // Other FFT traits to give the user?
            };
        }
        __NEW__validateAny(value) {
            return value.magnitude != undefined && value.phase != undefined;
        }
        __NEW__toAudioData(value, sampleIndex) {
            const sync = sampleIndex == undefined ?
                range(value.magnitude.length)
                : sampleIndex;
            return {
                audioStreams: [
                    sync,
                    value.magnitude,
                    value.phase
                ]
            };
        }
        __OLD__validate(value, { checkLength }) {
            if (value == undefined) {
                throw new Error("Expected STFT data, got undefined.");
            }
            if (value.magnitude == undefined || value.phase == undefined) {
                throw new Error("STFT data must have keys magnitude and phase. Given: " + value);
            }
            for (let key of ["magnitude", "phase"]) {
                const arr = value[key];
                if (!isArrayLike(value)) {
                    throw new Error(`Each STFT value must be an ArrayLike collection of numbers. Given ${key} value with no length property or numeric values.`);
                }
                if (checkLength && arr.length != this.windowSize) {
                    throw new Error(`Returned size must be equal to the input FFT windowSize. Expected ${this.windowSize}, given ${key}.length=${arr.length}.`);
                }
            }
        }
        __OLD__channelToAudioData(value) {
            return {
                audioStreams: [
                    range(value.magnitude.length), // sync signal.
                    value.magnitude,
                    value.phase
                ].map(toMultiChannelArray)
            };
        }
    }
    class audio extends IODatatype {
        constructor() {
            super(...arguments);
            this.dataspecString = 'ArrayLike<number>';
            this.numAudioStreams = 1;
        }
        __NEW__validateAny(value) {
            return isType(value, Number) || isArrayLike(value);
        }
        __NEW__toAudioData(value, sampleIndex) {
            throw new Error("Method not implemented.");
        }
        __OLD__validate(channel) {
            if (!isArrayLike(channel)) {
                throw new Error(`Each audio channel must be an ArrayLike collection of numbers. Given value with no length property or numeric values.`);
            }
            if (channel[0] != undefined && !isType(channel[0], Number)) {
                throw new Error(`Audio data must be numbers, given ${channel} (typeof ${typeof channel})`);
            }
        }
        channelFromAudioData(frame) {
            return frame.audioStreams[0];
        }
        __OLD__channelToAudioData(channel) {
            if (!(channel instanceof Array)) {
                throw new Error(`Audio data must be an array, given type ${typeof channel}.`);
            }
            channel = channel.map(v => isFinite(+v) ? v : 0);
            return {
                audioStreams: [toMultiChannelArray(channel)]
            };
        }
    }
    class control extends IODatatype {
        __NEW__validateAny(value) {
            throw new Error("control is not a valid return type.");
        }
        __NEW__toAudioData(value, sampleIndex) {
            throw new Error("control is not a valid return type.");
        }
        __OLD__validate(value) {
            throw new Error("control is not a valid return type.");
        }
        constructor(parameterKey) {
            super();
            this.parameterKey = parameterKey;
            this.dataspecString = 'any';
            this.numAudioStreams = 0;
        }
        channelFromAudioData(frame) {
            if (frame.parameters == undefined) {
                throw new Error(`undefined parameters, expected key ${this.parameterKey}`);
            }
            return frame.parameters[this.parameterKey];
        }
        __OLD__channelToAudioData(value) {
            // TODO: how would someone specify the output name?
            return {
                audioStreams: [],
                parameters: { [this.parameterKey]: value }
            };
        }
    }
    // TODO: use named outputs.
    /**
     * Converts a frame of audio data + metadata to and from function I/O types exposed to the user-defined function. The frame may be of any dimension.
     */
    class FrameToSignatureConverter {
        constructor(dimension, inputSpec, outputSpec) {
            this.dimension = dimension;
            this.inputSpec = inputSpec;
            this.outputSpec = outputSpec;
        }
        /**
         * Convert raw audio frame data into user-friendly function inputs.
         */
        prepareInputs(frame) {
            // TODO: fix this function.
            let streamIndex = 0;
            const inputs = [];
            for (const { type } of this.inputSpec) {
                // TODO: figure out how to pass multiple streams to a channel...
                const inputStreams = ArrayView.createSliceView(frame.audioStreams, streamIndex, streamIndex + type.numAudioStreams);
                const input = mapOverChannels(this.dimension, frame.audioStreams, channel => {
                    type.channelFromAudioData({
                        audioStreams: inputStreams,
                        parameters: frame.parameters
                    });
                });
                inputs.push(input);
            }
            return inputs;
        }
        normalizeOutputs(outputs) {
            // try-catch led to terrible performance, using validation instead.
            const originalErrors = this.validateOutputs(outputs);
            if (!originalErrors.length) {
                return outputs;
            }
            outputs = [outputs];
            const arrayErrors = this.validateOutputs(outputs);
            if (!arrayErrors.length) {
                return outputs;
            }
            throw new Error(`Unable to read outputs from processing function due to the following error(s):
${originalErrors.map(v => " - " + v).join("\n")}

Attempted to wrap output in an array, which failed as well:
${arrayErrors.map(v => " - " + v).join("\n")}`);
        }
        validateOutputs(outputs) {
            if (!isArrayLike(outputs)) {
                return [`Expected function outputs to be an array with the signature ${this.outputSpec} but got '${typeof outputs}' type instead.`];
            }
            if (outputs.length != this.outputSpec.length) {
                return [`Expected the function to have ${this.outputSpec.length} output(s), expressed as an array with length ${this.outputSpec.length}, but got array of length ${outputs.length} instead.`];
            }
            return map(outputs, (v, i) => {
                const spec = this.outputSpec[i];
                // TODO: account for different dimension in datatype string.
                if (!isCorrectOutput(this.dimension, v, spec.type)) {
                    return `Error parsing output ${i} ('${spec.name}') of function with dimension='${this.dimension}'. Expected datatype ${spec.type}, given ${v}.`;
                }
                return '';
            }).filter(v => !!v);
        }
        __OLD__validateOutputs(outputs) {
            if (!isArrayLike(outputs)) {
                throw new Error(`Expected function outputs to be an array with the signature ${this.outputSpec} but got '${typeof outputs}' type instead.`);
            }
            if (outputs.length != this.outputSpec.length) {
                throw new Error(`Expected function outputs to be an array with size ${this.outputSpec.length} but got size ${outputs.length} instead.`);
            }
            const itOutputs = ArrayView.createSliceView(outputs);
            const checkLength = ["all", "time"].includes(this.dimension);
            for (const [output, spec] of zip(itOutputs, this.outputSpec)) {
                try {
                    mapOverChannels(this.dimension, output, channel => spec.type.__OLD__validate(channel, { checkLength }));
                }
                catch (e) {
                    e.message = `Error parsing output '${spec.name}' with expected datatype ${spec.type}. ${e.message}`;
                    throw e;
                }
            }
        }
        /**
         * Convert user output back into raw data.
         */
        processOutputs(outputs) {
            const outputAudioStreamParts = [];
            for (const [output, specEntry] of zip(outputs, this.outputSpec)) {
                try {
                    const streams = this.outputToAudioStreams(output, specEntry.type);
                    outputAudioStreamParts.push(streams);
                }
                catch (e) {
                    throw new Error(`Expected function outputs to be an array with the signature ${this.outputSpec} but unable to convert output '${specEntry.name}' to the expected type (${specEntry.type}): ${e.message}`);
                }
            }
            return {
                audioStreams: ArrayView.createConcatView(...outputAudioStreamParts)
            };
        }
        outputToAudioStreams(output, type) {
            const audioStreams = [];
            // Because channelToAudioData can return multiple streams, we have to do 
            // some funny business. The large dimension returned at the "channel" level 
            // needs to be pushed to the topmost dimension (output level).
            const channelByAudioStream = range(type.numAudioStreams).fill([]);
            // 1. Collect flattened output by audioStream index.
            mapOverChannels(this.dimension, output, channel => {
                // TODO: how to handle parameters? Are output parameters allowed?
                const data = type.__OLD__channelToAudioData(channel);
                for (const i of range(type.numAudioStreams)) {
                    channelByAudioStream[i].push(data.audioStreams[i]);
                }
            });
            // 2. For each audioStream index, create a top-level audioStream by reading 
            // from the flattened array.
            for (const i of range(type.numAudioStreams)) {
                let j = 0; // Indexes the "flattened" array.
                const stream = mapOverChannels(this.dimension, output, _ => channelByAudioStream[i][j++]);
                audioStreams.push(stream);
            }
            return audioStreams;
        }
    }

    class ArrayFunctionality {
        constructor(length) {
            this.length = length;
            for (const i of range(length)) {
                Object.defineProperty(this, i, {
                    get() {
                        return this.getItem(i);
                    }
                });
            }
        }
        *[Symbol.iterator]() {
            for (const i of range(this.length)) {
                yield this[i];
            }
        }
    }
    /**
     * Specifies a configuration of inputs / outputs grouped into channels and the name of each one.
     *
     */
    class TypedStreamSpec extends ArrayFunctionality {
        constructor({ names, numStreams, numChannelsPerStream, types }) {
            var _a, _b, _c;
            super((_c = (_b = (_a = numStreams !== null && numStreams !== void 0 ? numStreams : types === null || types === void 0 ? void 0 : types.length) !== null && _a !== void 0 ? _a : names === null || names === void 0 ? void 0 : names.length) !== null && _b !== void 0 ? _b : numChannelsPerStream === null || numChannelsPerStream === void 0 ? void 0 : numChannelsPerStream.length) !== null && _c !== void 0 ? _c : 0);
            types && (numStreams !== null && numStreams !== void 0 ? numStreams : (numStreams = types.length));
            if (names != undefined
                && numStreams != undefined
                && numStreams != names.length
                || numChannelsPerStream != undefined
                    && numStreams != undefined
                    && numStreams != numChannelsPerStream.length
                || numChannelsPerStream instanceof Array
                    && names != undefined
                    && numChannelsPerStream.length != names.length) {
                throw new Error(`If provided, numStreams, inputNames, and numChannelsPerStream must match. Given numStreams=${numStreams}, inputNames=${JSON.stringify(names)}, numChannelsPerStream=${numChannelsPerStream}.`);
            }
            // Store whether the names were auto-generated.
            this.hasNumberedNames = names == undefined;
            this.hasDefaultNumChannels = numChannelsPerStream == undefined;
            if (numChannelsPerStream != undefined) {
                const info = this.infoFromChannelsPerStream(numChannelsPerStream);
                numStreams !== null && numStreams !== void 0 ? numStreams : (numStreams = info.numStreams);
                names !== null && names !== void 0 ? names : (names = info.names);
            }
            else if (names != undefined) {
                const info = this.infoFromNames(names);
                numStreams !== null && numStreams !== void 0 ? numStreams : (numStreams = info.numStreams);
                numChannelsPerStream !== null && numChannelsPerStream !== void 0 ? numChannelsPerStream : (numChannelsPerStream = info.numChannelsPerStream);
            }
            else if (numStreams != undefined) {
                const info = this.infoFromNumStreams(numStreams);
                numChannelsPerStream !== null && numChannelsPerStream !== void 0 ? numChannelsPerStream : (numChannelsPerStream = info.numChannelsPerStream);
                names !== null && names !== void 0 ? names : (names = info.names);
            }
            else {
                throw new Error("At least one of (names, numStreams, numChannelsPerStream) must be specified.");
            }
            types !== null && types !== void 0 ? types : (types = names.map(_ => new audio()));
            // These will all be defined at this point.
            this.names = names;
            this.length = numStreams;
            this.numChannelsPerStream = numChannelsPerStream;
            this.types = types.map((v, i) => isType(v, IODatatype) ?
                v
                : IODatatype.create(v, this.names[i]));
        }
        static fromSerialized(streamSpec) {
            const types = streamSpec.types.map(t => t.name);
            return new TypedStreamSpec(Object.assign(Object.assign({}, streamSpec), { types }));
        }
        getItem(i) {
            return {
                name: this.names[i],
                numChannels: this.numChannelsPerStream[i],
                type: this.types[i]
            };
        }
        get totalNumChannels() {
            return sum(Object.values(this.numChannelsPerStream));
        }
        infoFromNames(names) {
            return {
                numStreams: names.length,
                numChannelsPerStream: range(names.length).fill(constants.DEFAULT_NUM_CHANNELS)
            };
        }
        infoFromNumStreams(numStreams) {
            return {
                numChannelsPerStream: range(numStreams).fill(constants.DEFAULT_NUM_CHANNELS),
                names: range(numStreams)
            };
        }
        infoFromChannelsPerStream(numChannelsPerStream) {
            return {
                names: range(numChannelsPerStream.length),
                numStreams: numChannelsPerStream.length
            };
        }
        toString() {
            const specString = map(this, data => {
                let streamString = `'${data.name}': ${data.type.name}`;
                if (data.numChannels) {
                    streamString += ` (${data.numChannels} channels)`;
                }
                return streamString;
            }).join(", ");
            return `[${specString}]`;
        }
    }

    /**
     * A data structure storing the last N values in a time series.
     *
     * It is implemented as a circular array to avoid processing when the time step
     * is incremented.
     *
     * Here's a demonstration with eaach t[n] being an absolute time, | showing
     * the position of the offset, and _ being the default value.
     *
     * "Initial" state storing the first 4 values:
     * - circularBuffer: [|v3 v2 v1 v0]
     * - offset: 0
     *
     * > get(0) = v3
     * > get(1) = v2
     * > get(4) = _
     *
     * After add(v4):
     * - circularBuffer: [v3 v2 v1 | v4]
     * - offset: 3
     *
     * > get(0) = v4
     * > get(1) = v3
     *
     * After setSize(8):
     * - circularBuffer: [|v4 v3 v2 v1 _ _ _ _]
     * - offset: 0
     *
     */
    class MemoryBuffer {
        constructor(defaultValueFn) {
            this.defaultValueFn = defaultValueFn;
            this.circularBuffer = [];
            // offset will always be within range, and circularBuffer[offset] is the 
            // most recent value (circularBuffer[offset+1] is the one before that, etc.)
            this.offset = 0;
        }
        get length() {
            return this.circularBuffer.length;
        }
        toInnerIndex(i) {
            return (i + this.offset) % this.length;
        }
        /**
         * Get the ith value of the memory. Note that index 0 is the previous value, not 1.
         */
        get(i) {
            if (i >= this.length) {
                return this.defaultValueFn();
            }
            else {
                const innerIdx = this.toInnerIndex(i);
                return this.circularBuffer[innerIdx];
            }
        }
        /**
         * Add `val` to the array of memory, incrementing the time step. If `length` is zero, this is a no-op.
         *
         * NOTE: to add without discarding old values, always call setSize first.
         */
        add(val) {
            if (this.length) {
                const clone = JSON.parse(JSON.stringify(val)); // TODO: need this?
                // Modular subtraction by 1.
                this.offset = (this.offset + this.length - 1) % this.length;
                this.circularBuffer[this.offset] = clone;
            }
        }
        setSize(size) {
            const newBuffer = [];
            for (let i = 0; i < size; i++) {
                newBuffer.push(this.get(i));
            }
            this.circularBuffer = newBuffer;
            this.offset = 0;
        }
    }

    class SignalProcessingContext {
        constructor(inputMemory, outputMemory, { windowSize, currentTime, frameIndex, sampleRate, ioConverter, channelIndex = undefined, sampleIndex = undefined }) {
            this.inputMemory = inputMemory;
            this.outputMemory = outputMemory;
            this.maxInputLookback = 0;
            this.maxOutputLookback = 0;
            this.fixedInputLookback = -1;
            this.fixedOutputLookback = -1;
            this.currentTime = currentTime + ((sampleIndex !== null && sampleIndex !== void 0 ? sampleIndex : 0) / sampleRate);
            this.windowSize = windowSize;
            this.sampleIndex = sampleIndex;
            this.channelIndex = channelIndex;
            this.frameIndex = frameIndex;
            this.sampleRate = sampleRate;
            this.numInputs = ioConverter.inputSpec.length;
            this.numOutputs = ioConverter.outputSpec.length;
            this.ioConverter = ioConverter;
        }
        // TODO: consider making this 1-based to make previousInputs(0) be the current.
        previousInputs(t = 0) {
            // Inputs may be float32 which will not represent an int perfectly.
            t = Math.round(t);
            this.maxInputLookback = Math.max(t + 1, this.maxInputLookback);
            return this.inputMemory.get(t);
        }
        previousOutputs(t = 0) {
            // Inputs may be float32 which will not represent an int perfectly.
            t = Math.round(t);
            this.maxOutputLookback = Math.max(t + 1, this.maxOutputLookback);
            return this.outputMemory.get(t);
        }
        setOutputMemorySize(n) {
            // Inputs may be float32 which will not represent an int perfectly.
            n = Math.round(n);
            this.fixedOutputLookback = n;
        }
        setInputMemorySize(n) {
            // Inputs may be float32 which will not represent an int perfectly.
            n = Math.round(n);
            this.fixedInputLookback = n;
        }
        execute(fn, inputs) {
            // Execute the function, making the Context properties and methods available
            // within the user-supplied function.
            const rawOutput = fn.bind(this)(...inputs);
            const outputs = this.ioConverter.normalizeOutputs(rawOutput);
            // If the function tried to access past inputs or force-rezised the memory, 
            // resize.
            SignalProcessingContext.resizeMemory(this.inputMemory, this.maxInputLookback, this.fixedInputLookback);
            SignalProcessingContext.resizeMemory(this.outputMemory, this.maxOutputLookback, this.fixedOutputLookback);
            // Update memory after resizing.
            this.inputMemory.add(inputs);
            this.outputMemory.add(outputs);
            return outputs;
        }
        static resizeMemory(memory, maxLookback, lookbackOverride) {
            if (lookbackOverride > 0) {
                memory.setSize(lookbackOverride);
            }
            else if (maxLookback > memory.length) {
                memory.setSize(maxLookback);
            }
        }
    }

    const ALL_CHANNELS = -1;
    /**
     * A class collecting all current ongoing memory streams. Because some `dimension` settings process channels in parallel (`"none"` and `"time"`), memory streams are indexed by channel.
     */
    class SignalProcessingContextFactory {
        constructor({ inputSpec, outputSpec, windowSize, dimension, getFrameIndex, getCurrentTime, sampleRate, }) {
            this.inputHistory = {};
            this.outputHistory = {};
            this.windowSize = windowSize;
            this.sampleRate = sampleRate;
            this.inputSpec = inputSpec;
            this.outputSpec = outputSpec;
            this.getCurrentTime = getCurrentTime;
            this.getFrameIndex = getFrameIndex;
            this.ioConverter = new FrameToSignatureConverter(dimension, inputSpec, outputSpec);
            const genInput = this.getDefaultValueFn({
                dimension,
                windowSize,
                numChannelsPerStream: inputSpec.numChannelsPerStream
            });
            const genOutput = this.getDefaultValueFn({
                dimension,
                windowSize,
                numChannelsPerStream: outputSpec.numChannelsPerStream
            });
            const hasChannelSpecificProcessing = ["all", "channels"].includes(dimension);
            if (hasChannelSpecificProcessing) {
                this.inputHistory[ALL_CHANNELS] = new MemoryBuffer(genInput);
                this.outputHistory[ALL_CHANNELS] = new MemoryBuffer(genOutput);
            }
            else {
                if (!allEqual(inputSpec.numChannelsPerStream)) {
                    throw new Error(`Only dimensions 'all' and 'channels' may have inconsistent numbers of input channels. Given dimension=${dimension}, inputSpec=${inputSpec}.`);
                }
                if (!allEqual(outputSpec.numChannelsPerStream)) {
                    throw new Error(`Only dimensions 'all' and 'channels' may have inconsistent numbers of output channels. Given dimension=${dimension}, outputSpec=${outputSpec}.`);
                }
                // Each channel is processed the same.
                for (let c = 0; c < inputSpec.numChannelsPerStream[0]; c++) {
                    this.inputHistory[c] = new MemoryBuffer(genInput);
                }
                for (let c = 0; c < outputSpec.numChannelsPerStream[0]; c++) {
                    this.outputHistory[c] = new MemoryBuffer(genOutput);
                }
            }
        }
        getDefaultValueFn({ dimension, windowSize, numChannelsPerStream }) {
            return function genValue() {
                const defaultValue = [];
                for (let i = 0; i < numChannelsPerStream.length; i++) {
                    defaultValue.push(generateZeroInput(dimension, windowSize, numChannelsPerStream[i]));
                }
                return defaultValue;
            };
        }
        getContext({ channelIndex = ALL_CHANNELS, sampleIndex = undefined } = {}) {
            const inputMemory = this.inputHistory[channelIndex];
            const outputMemory = this.outputHistory[channelIndex];
            return new SignalProcessingContext(inputMemory, outputMemory, {
                windowSize: this.windowSize,
                channelIndex,
                sampleIndex,
                ioConverter: this.ioConverter,
                sampleRate: this.sampleRate,
                frameIndex: this.getFrameIndex(),
                currentTime: this.getCurrentTime()
            });
        }
    }

    /* Serialization */
    function deserializeWorkletMessage(message, sampleRate, getCurrentTime, getFrameIndex) {
        const originalTraceback = message.tracebackString;
        const innerFunction = new Function('return ' + message.fnString)();
        const applyToChunk = getProcessingFunction(message.dimension);
        const contextFactory = new SignalProcessingContextFactory(Object.assign(Object.assign({}, message), { 
            // These need to be rebuilt after serialization.
            inputSpec: TypedStreamSpec.fromSerialized(message.inputSpec), outputSpec: TypedStreamSpec.fromSerialized(message.outputSpec), 
            // Each environment may get this information from different places.
            sampleRate,
            getCurrentTime,
            getFrameIndex }));
        return function processFn(inputs, outputs, __parameters) {
            try {
                // Apply across dimensions.
                applyToChunk(innerFunction, inputs, outputs, contextFactory);
            }
            catch (e) {
                console.error(`Encountered worklet error while processing the following input frame:`);
                console.error(inputs);
                if (e.stack) {
                    e.stack = `${e.stack}\n\nMain thread stack trace: ${originalTraceback}`;
                }
                throw e;
            }
        };
    }

    const FUNCTION_WORKLET_NAME = "function-worklet";
    class OperationWorklet extends SafeAudioWorkletProcessor {
        constructor({ processorOptions: { inputChannelCount } }) {
            super();
            this.inputChannelCount = inputChannelCount;
            // Receives serialized input sent from postMessage() calls.
            // This is used to change the processing function at runtime.
            this.port.onmessage = (event) => {
                const windowSize = event.data.windowSize;
                this.processImpl = deserializeWorkletMessage(event.data, sampleRate, () => currentTime, () => Math.floor(currentFrame / windowSize));
            };
        }
        resizeChannels(channels, expectedNumChannels) {
            // Ensures the input data has the right size.
            if (channels.length == 0 || channels.length > expectedNumChannels) {
                return channels.slice(0, expectedNumChannels);
            }
            else {
                // TODO: make this expansion follow better logic than repeating channels.
                let newChannels = channels;
                while (newChannels.length < expectedNumChannels) {
                    newChannels = [...newChannels, ...channels];
                }
                return newChannels;
            }
        }
        process(inputs, outputs, parameters) {
            inputs = inputs.map((v, i) => this.resizeChannels(v, this.inputChannelCount[i]));
            this.processImpl && this.processImpl(inputs, outputs, parameters);
            return true;
        }
    }

    const RECORDER_WORKLET_NAME = "recorder-worklet";
    class RecorderWorklet extends SafeAudioWorkletProcessor {
        constructor() {
            super();
            // Chunks of audio data. Dimensions: [input, channel, chunk]
            this.floatDataChunks = [];
            this.isRecording = false;
            // After how many samples should the method return.
            this.maxNumSamples = Infinity;
            this.currNumSamples = 0;
            this.port.onmessage = (event) => {
                this.handleMessage(event.data);
            };
        }
        handleMessage(data) {
            if (data.command == 'start') {
                this.start(data.numSamples);
            }
            else if (data.command == 'stop') {
                this.stop();
            }
            else {
                throw new Error(`Unrecognized data: ${JSON.stringify(data)}`);
            }
        }
        start(numSamples) {
            this.floatDataChunks = [];
            this.maxNumSamples = numSamples !== null && numSamples !== void 0 ? numSamples : Infinity;
            this.currNumSamples = 0;
            this.isRecording = true;
        }
        stop() {
            this.isRecording = false;
            const joinedData = map2d(this.floatDataChunks, chunks => joinTypedArrays(chunks, Float32Array, this.maxNumSamples)).filter(input => input.length);
            // Remove need for copy by transferring underlying ArrayBuffers to the 
            // main thread. See https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Transferable_objects#transferring_objects_between_threads 
            // for more details.
            const movedObjects = map2d(joinedData, c => c.buffer).flat();
            this.port.postMessage(joinedData, movedObjects);
            // Re-initialize; the old data is in an invalid state.
            this.floatDataChunks = [];
        }
        process(inputs, __outputs, __parameters) {
            var _a, _b;
            if (this.isRecording) {
                if (this.currNumSamples > this.maxNumSamples) {
                    this.stop();
                    return true;
                }
                for (let i = 0; i < inputs.length; i++) {
                    const input = inputs[i];
                    const chunks = (_a = this.floatDataChunks[i]) !== null && _a !== void 0 ? _a : [];
                    this.floatDataChunks[i] = chunks;
                    for (let c = 0; c < input.length; c++) {
                        // Create channel if not exists, and append to it.
                        const chunkArray = (_b = chunks[c]) !== null && _b !== void 0 ? _b : [];
                        chunkArray.push(new Float32Array(input[c]));
                        chunks[c] = chunkArray;
                    }
                }
                inputs[0] && (this.currNumSamples += inputs[0][0].length);
            }
            return true;
        }
    }

    // Entry point for the worklet.
    // Register the AudioWorkletProcessors (if in Worklet)
    if (IS_WORKLET) {
        registerProcessor(FUNCTION_WORKLET_NAME, OperationWorklet);
        registerProcessor(BUFFER_WORKLET_NAME, BufferWorklet);
        registerProcessor(RECORDER_WORKLET_NAME, RecorderWorklet);
        registerProcessor(BUFFER_WRITER_WORKLET_NAME, BufferWriterWorklet);
        registerProcessor(FFT_WORKLET_NAME, FFTWorklet);
        registerProcessor(IFFT_WORKLET_NAME, IFFTWorklet);
    }

})();
